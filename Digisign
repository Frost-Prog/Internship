package IMPS_Generate_DigitalSign;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.io.StringWriter;
import java.security.KeyException;
import java.security.KeyStore;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.util.Collections;

import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.XMLSignature;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.KeyValue;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.crypto.dsig.spec.TransformParameterSpec;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import com.ibm.broker.javacompute.MbJavaComputeNode;
import com.ibm.broker.plugin.MbElement;
import com.ibm.broker.plugin.MbException;
import com.ibm.broker.plugin.MbMessage;
import com.ibm.broker.plugin.MbMessageAssembly;
import com.ibm.broker.plugin.MbOutputTerminal;
import com.ibm.broker.plugin.MbUserException;
import com.ibm.broker.plugin.MbXMLNSC;

public class SF_IMPS_Generate_DigitalSign extends MbJavaComputeNode {

	private KeyStore.PrivateKeyEntry keyEntry;
	public void evaluate(MbMessageAssembly inAssembly) throws MbException {
		MbOutputTerminal out = getOutputTerminal("out");
		
		MbMessage inMessage = inAssembly.getMessage();
		MbMessageAssembly outAssembly = null;
		try {
			int ccsid = 0;
			// create new message as a copy of the input
			MbMessage outMessage = new MbMessage();
			outAssembly = new MbMessageAssembly(inAssembly, outMessage);
		
			MbElement outRoot = outMessage.getRootElement();
			MbElement xmlMessage = inMessage.getRootElement().getLastChild();  
			byte[] xml = xmlMessage.toBitstream(null, null, null, 0, ccsid, 0);
			String msg = new String(xml);		
			String SignatureValue = new String(createDigitalSignature(msg));
			
			MbElement outParser = outRoot.createElementAsLastChild(MbXMLNSC.PARSER_NAME);		
			outParser.createElementAsLastChild(MbElement.TYPE_VALUE,"DigiSign",SignatureValue);		         
			
		} catch (MbException e) {			
			throw e;
		} catch (RuntimeException e) {
			throw e;
		} catch (Exception e) {
			throw new MbUserException(this, "evaluate()", "", "", e.toString(),
					null);
		}		
		
		out.propagate(outAssembly);
	}

		
	public String createDigitalSignature(String message) throws Exception {
	    String outPut="";
		try{
			this.keyEntry = getKeyFromKeyStore();
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			dbf.setNamespaceAware(true);
			Document inputDocument = dbf.newDocumentBuilder().parse(new InputSource(new StringReader(message)));	      
			Document signedDocument = generateSignValue(inputDocument,true);
      
			StringWriter stringWriter = new StringWriter();
			TransformerFactory tf = TransformerFactory.newInstance();
			Transformer trans = tf.newTransformer();
			trans.transform(new DOMSource(signedDocument), new StreamResult(stringWriter));
			outPut = stringWriter.getBuffer().toString();
	      
		}
		catch (Exception e){
			throw new RuntimeException("Error while digitally signing the XML document", e);
		}		
		
		return outPut;
	}
	
	
	private KeyStore.PrivateKeyEntry getKeyFromKeyStore() {
	    InputStream keyFileStream = null;
	    try {
				String KeystorePathValue = getUserDefinedAttribute("KeystorePath").toString();
				String KeystorePasswordValue = getUserDefinedAttribute("KeystorePassword").toString();
				String KeystoreAliasNameValue = getUserDefinedAttribute("AliasFilename").toString();
				char[] password = KeystorePasswordValue.toCharArray();
				KeyStore ks = KeyStore.getInstance("jks");
	  	        keyFileStream = new FileInputStream(KeystorePathValue);
			    ks.load(keyFileStream, password);
			    KeyStore.PrivateKeyEntry key = (KeyStore.PrivateKeyEntry)ks.getEntry(KeystoreAliasNameValue, new KeyStore.PasswordProtection(password));
	            return key;
	    }
	    catch (Exception e) {
	      e.printStackTrace();
	      return null;
	    } finally {
	      if (keyFileStream != null) {
	        try {
	          keyFileStream.close();
	        } catch (IOException e) {
	          e.printStackTrace();
	        } 
	      }
	    } 
	  }
	
		
	public Document generateSignValue(Document xmlDoc, boolean includeKeyInfo) throws Exception {
	    XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");	    
	    Reference ref = fac.newReference("", fac.newDigestMethod("http://www.w3.org/2001/04/xmlenc#sha256", null), 
	        Collections.singletonList(fac
	          .newTransform("http://www.w3.org/2000/09/xmldsig#enveloped-signature", (TransformParameterSpec)null)), null, null);
	    
	    SignedInfo sInfo = fac.newSignedInfo(fac.newCanonicalizationMethod("http://www.w3.org/TR/2001/REC-xml-c14n-20010315", (C14NMethodParameterSpec)null), fac
	        .newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256", null), 
	        
	    Collections.singletonList(ref));  
	    	    
	    if (this.keyEntry == null) {
	      throw new RuntimeException("Key could not be read for digital signature. Please check value of signature alias and signature password, and restart the Auth Client");
	    }	    
	    X509Certificate x509Cert = (X509Certificate)this.keyEntry.getCertificate();    
	    KeyInfo kInfo = getKeyInfo(fac, x509Cert.getPublicKey());
	    DOMSignContext dsc = new DOMSignContext(this.keyEntry.getPrivateKey(), xmlDoc.getDocumentElement());
	    XMLSignature signature = fac.newXMLSignature(sInfo, includeKeyInfo ? kInfo : null);
	    signature.sign(dsc);
	    
	    Node node = dsc.getParent();	  
	    return node.getOwnerDocument();
	  }
	
	private KeyInfo getKeyInfo(XMLSignatureFactory xmlSigFactory, PublicKey publicKey) {
	    KeyValue keyValue = null;
	    KeyInfoFactory keyInfoFact = xmlSigFactory.getKeyInfoFactory();
	    try {
	      keyValue = keyInfoFact.newKeyValue(publicKey);
	    } catch (KeyException ex) {
	      ex.printStackTrace();
	    } 
	    return keyInfoFact.newKeyInfo(Collections.singletonList(keyValue));
	  }

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.sbi.tcs;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.io.StringWriter;
import java.security.KeyException;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Properties;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.XMLSignature;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.KeyValue;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.crypto.dsig.spec.TransformParameterSpec;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

import com.ibm.broker.javacompute.MbJavaComputeNode;
import com.ibm.broker.plugin.MbElement;
import com.ibm.broker.plugin.MbException;
import com.ibm.broker.plugin.MbMessage;
import com.ibm.broker.plugin.MbMessageAssembly;
import com.ibm.broker.plugin.MbOutputTerminal;
import com.ibm.broker.plugin.MbUserException;
import com.ibm.broker.plugin.MbXMLNSC;
import com.ibm.misc.BASE64Decoder;

public class ThirdPartyGenericComplaintUdir_sys_JavaCompute extends MbJavaComputeNode {
	
	static String jkspath="/opt/IBM/RSAKeystore/ibmdevportal.jks";
	static String propertiesPath="/opt/IBM/PropertyFile/KeyMapper.properties";
	static String jkspwd,enpass= "";
	
	private KeyStore.PrivateKeyEntry keyEntry;
	public void evaluate(MbMessageAssembly inAssembly) throws MbException {
		MbOutputTerminal out = getOutputTerminal("out");
		
		MbMessage inMessage = inAssembly.getMessage();
		MbMessageAssembly outAssembly = null;
		try {
			int ccsid = 0;
			// create new message as a copy of the input
			MbMessage outMessage = new MbMessage();
			outAssembly = new MbMessageAssembly(inAssembly, outMessage);
		
			MbElement outRoot = outMessage.getRootElement();
			MbElement xmlMessage = inMessage.getRootElement().getLastChild();  
			byte[] xml = xmlMessage.toBitstream(null, null, null, 0, ccsid, 0);
			String msg = new String(xml);		
			String SignatureValue = new String(createDigitalSignature(msg));
			
			MbElement outParser = outRoot.createElementAsLastChild(MbXMLNSC.PARSER_NAME);		
			outParser.createElementAsLastChild(MbElement.TYPE_VALUE,"DigiSign",SignatureValue);		         
			
		} catch (MbException e) {			
			throw e;
		} catch (RuntimeException e) {
			throw e;
		} catch (Exception e) {
			throw new MbUserException(this, "evaluate()", "", "", e.toString(),
					null);
		}		
		
		out.propagate(outAssembly);
	}

		
	public String createDigitalSignature(String message) throws Exception {
	    String outPut="";
		try{
			
//			this.keyEntry = getKeyFromKeyStore();
//			this.keyEntry = getPrivateKey();
			
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			dbf.setNamespaceAware(true);
			Document inputDocument = dbf.newDocumentBuilder().parse(new InputSource(new StringReader(message)));
			Document signedDocument = generateSignValue(inputDocument,true);
      
			StringWriter stringWriter = new StringWriter();
			TransformerFactory tf = TransformerFactory.newInstance();
			Transformer trans = tf.newTransformer();
			trans.transform(new DOMSource(signedDocument), new StreamResult(stringWriter));
//			outPut = stringWriter.getBuffer().toString();
	      
		}
		catch (Exception e){
			throw new RuntimeException("Error while digitally signing the XML document", e);
		}		
		
		return outPut;
	}
	
	
	private KeyStore.PrivateKeyEntry getKeyFromKeyStore() {
	    InputStream keyFileStream = null;
	    jkspwd = getProperty("aesk", propertiesPath); 
			enpass = getProperty("enpass", propertiesPath);
			jkspwd = AESDecrypt(enpass, jkspwd);
	    try {
				String KeystorePathValue = getUserDefinedAttribute("/opt/IBM/RSAKeystore/ibmdevportal.jks").toString();
				System.out.println(jkspwd);
				String KeystorePasswordValue = getUserDefinedAttribute(jkspwd).toString();
				String KeystoreAliasNameValue = getUserDefinedAttribute("").toString();
				char[] password = KeystorePasswordValue.toCharArray();
				KeyStore ks = KeyStore.getInstance("jks");
	  	        keyFileStream = new FileInputStream(KeystorePathValue);
			    ks.load(keyFileStream, password);
			    KeyStore.PrivateKeyEntry key = (KeyStore.PrivateKeyEntry)ks.getEntry(KeystoreAliasNameValue, new KeyStore.PasswordProtection(password));
			    System.out.println(key);
	            return key;
	    }
	    catch (Exception e) {
	      e.printStackTrace();
	      return null;
	    } finally {
	      if (keyFileStream != null) {
	        try {
	          keyFileStream.close();
	        } catch (IOException e) {
	          e.printStackTrace();
	        } 
	      }
	    } 
	  }
	
	static String base64PrivateKey, base64publickey = null;
	
	public static String getPrivateKey() {
		try {
			jkspwd = getProperty("aesk", propertiesPath);
			enpass = getProperty("enpass", propertiesPath);
			boolean isAliasWithPrivateKey = false;
			KeyStore keyStore = KeyStore.getInstance("JKS");
			jkspwd = AESDecrypt(enpass, jkspwd);
			if (!jkspwd.contains("X-JavaError")) {
				keyStore.load(new FileInputStream(jkspath), jkspwd.toCharArray());
				Enumeration<String> es = keyStore.aliases();
				String alias = "";
				while (es.hasMoreElements()) {
					alias = (String) es.nextElement();
					if (isAliasWithPrivateKey = keyStore.isKeyEntry(alias)) {
						break;
					}
				}
				if (isAliasWithPrivateKey) {
					KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias,
							new KeyStore.PasswordProtection(jkspwd.toCharArray()));
					PrivateKey myPrivateKey = pkEntry.getPrivateKey();
					byte[] privateKey = (myPrivateKey.getEncoded());
					base64PrivateKey = DatatypeConverter.printBase64Binary(privateKey);
				}
			} else {
				base64PrivateKey = jkspwd + " : Error in Decryption of keystore password";
			}
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
		return base64PrivateKey;
	}
		
	public Document generateSignValue(Document xmlDoc, boolean includeKeyInfo) throws Exception {
	    XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");	    
	    Reference ref = fac.newReference("", fac.newDigestMethod("http://www.w3.org/2001/04/xmlenc#sha256", null), 
	        Collections.singletonList(fac
	          .newTransform("http://www.w3.org/2000/09/xmldsig#enveloped-signature", (TransformParameterSpec)null)), null, null);
	    
	    SignedInfo sInfo = fac.newSignedInfo(fac.newCanonicalizationMethod("http://www.w3.org/TR/2001/REC-xml-c14n-20010315", (C14NMethodParameterSpec)null), fac
	        .newSignatureMethod("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256", null), 
	        
	    Collections.singletonList(ref));  
	    	    
	    if (this.keyEntry == null) {
	      throw new RuntimeException("Key could not be read for digital signature. Please check value of signature alias and signature password, and restart the Auth Client");
	    }	    
	    X509Certificate x509Cert = (X509Certificate)this.keyEntry.getCertificate();    
	    KeyInfo kInfo = getKeyInfo(fac, x509Cert.getPublicKey());
	    DOMSignContext dsc = new DOMSignContext(this.keyEntry.getPrivateKey(), xmlDoc.getDocumentElement());
	    XMLSignature signature = fac.newXMLSignature(sInfo, includeKeyInfo ? kInfo : null);
	    signature.sign(dsc);
	    
	    Node node = dsc.getParent();	  
	    return node.getOwnerDocument();
	  }
	
	private KeyInfo getKeyInfo(XMLSignatureFactory xmlSigFactory, PublicKey publicKey) {
	    KeyValue keyValue = null;
	    KeyInfoFactory keyInfoFact = xmlSigFactory.getKeyInfoFactory();
	    try {
	      keyValue = keyInfoFact.newKeyValue(publicKey);
	    } catch (KeyException ex) {
	      ex.printStackTrace();
	    } 
	    return keyInfoFact.newKeyInfo(Collections.singletonList(keyValue));
	  }
	public static String getProperty(String key,String propertiesPath)
	{		
		BufferedReader reader;
		try {
			reader = new BufferedReader(new FileReader(propertiesPath));
			Properties p = new Properties();
			p.load(reader);
			return p.getProperty(key);
      		} 		
		catch (Exception e){			
      		return "X-JavaError" +" " +e.toString();			
		    }	     	
   	}
	
	public static String AESDecrypt(String message, String key) {
		try {
			byte[] keybyte = key.getBytes("UTF-8");
			byte[] ivkey = Arrays.copyOf(keybyte, 16);
			IvParameterSpec iv = new IvParameterSpec(ivkey);
			byte[] encvalue = new BASE64Decoder().decodeBuffer(message);
			SecretKeySpec seckey = new SecretKeySpec(keybyte, "AES");
			Cipher c = Cipher.getInstance("AES/CBC/PKCS5PADDING");
			c.init(2, seckey, iv);
			byte[] decvalue = c.doFinal(encvalue);
			String decryptedvalue = new String(decvalue);
			return decryptedvalue;
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




package com.sbi.tcs;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.util.Arrays;
import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Properties;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

//import com.ibm.misc.BASE64Decoder;
//import com.ibm.misc.BASE64Encoder;

public class thirdPartyNpci {
	
	static String jkspwd,enpass= "";
 	static String base64PrivateKey,base64publickey = null;
 	static HashMap<String, String> hashmap_public = new HashMap<>();

	
//	static String certpath =  "/opt/IBM/EndPoint_Public/NPCISigner.cer";
	static String jkspath="/opt/IBM/RSAKeystore/ibmdevportal.jks";
	static String propertiesPath="/opt/IBM/PropertyFile/KeyMapper.properties";

	public static void main(String[] args) throws Exception {
		String Message1 = digitalSignature("This is EIS");
		System.out.println(Message1);
	}

//	public static String Sign(String message) throws Exception {
//	public static String Sign(String message) {
//		try {
//			// Creating Modulus and Exponent
//			FileInputStream fis = new FileInputStream(certpath);
//			CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
//			X509Certificate certificate = (X509Certificate) certificateFactory.generateCertificate(fis);
//			fis.close();
//
//			PublicKey publicKey = certificate.getPublicKey();
//			java.security.interfaces.RSAPublicKey rsaPublicKey = (java.security.interfaces.RSAPublicKey) publicKey;
//
//			byte[] modulusBytes = rsaPublicKey.getModulus().toByteArray();
//			byte[] exponentBytes = rsaPublicKey.getPublicExponent().toByteArray();
////			String signature = Sign(message, modulusBytes, exponentBytes);
////			System.out.println("DigitalSign:" + signature);
//
//			// sign the message
//			RSAPrivateKeySpec privateKeySpec = new RSAPrivateKeySpec(new java.math.BigInteger(modulusBytes),
//					new java.math.BigInteger(exponentBytes));
//			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
//			PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);
//
//			Signature signature = Signature.getInstance("SHA256withRSA");
//			signature.initSign(privateKey);
//			signature.update(message.getBytes());
//
//			byte[] signatureBytes = signature.sign();
//			String Modulus64 = Base64.getEncoder().encodeToString(modulusBytes);
//			String Exponent64 = Base64.getEncoder().encodeToString(exponentBytes);
////		System.out.println(Modulus64);
////		System.out.println(Exponent64);
//			String digiSign = digitalSignature(message);
//			String wDigisign = digiSign + "," + Modulus64 + "," + Exponent64;
//			return wDigisign;
//		} catch (Exception e) {
//			return e.toString();
//		}
//	}
//	
	public static String VerifySign(String message, String Modulus, String Exponent) {
		try {
			byte[] modulusBytes = Base64.getDecoder().decode(Modulus);
			byte[] exponentBytes = Base64.getDecoder().decode(Exponent);
		RSAPrivateKeySpec privateKeySpec = new RSAPrivateKeySpec(new java.math.BigInteger(modulusBytes),
				new java.math.BigInteger(exponentBytes));
		KeyFactory keyFactory = KeyFactory.getInstance("RSA");
		PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);

		Signature signature = Signature.getInstance("SHA256withRSA");
		signature.initSign(privateKey);
		signature.update(message.getBytes());
		byte[] signatureBytes = signature.sign();
		String digiSign = Base64.getEncoder().encodeToString(signatureBytes);

		return digiSign;
		}
		catch (Exception e) {
			return e.toString();
		}
	}
	
	public static String getProperty(String key,String propertiesPath)
	{		
		BufferedReader reader;
		try {
			reader = new BufferedReader(new FileReader(propertiesPath));
			Properties p = new Properties();
			p.load(reader);
			return p.getProperty(key);
      		} 		
		catch (Exception e){			
      		return "X-JavaError" +" " +e.toString();			
		    }	     	
   	}
	
	public static String digitalSignature(String data)
	{   
		byte[] encData= new byte[100];
		String str="";
		String modulus="";
		String exponent="";
		try {	
		 /*if (base64PrivateKey  == null)
	     {	
	     	base64PrivateKey = getPrivateKey();	
	     }*/
		 	base64PrivateKey = getPrivateKey();	
		 	//change .replaceAll("\r\n", "")
		    byte[] privebase64decKey = Base64.getDecoder().decode(base64PrivateKey);
		    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privebase64decKey);
	        KeyFactory keyFactory = KeyFactory.getInstance("RSA");	        
	        Signature privateSignature = Signature.getInstance("SHA256withRSA");
	        PrivateKey privaKey = keyFactory.generatePrivate(keySpec);
	        //this is to get modulus and exponent
	        
//	    	java.security.interfaces.RSAPrivateKey rsaPrivateKey = (java.security.interfaces.RSAPrivateKey) publicKey;
	    	
	    				
	        
	        
	        RSAPrivateKeySpec rsaPrivateKeySpec = keyFactory.getKeySpec(privaKey, RSAPrivateKeySpec.class);
	        byte[] modulusBytes = rsaPrivateKeySpec.getModulus().toByteArray();
	        byte[] exponentBytes = rsaPrivateKeySpec.getPrivateExponent().toByteArray();
	        
	        modulus = Base64.getEncoder().encodeToString(modulusBytes);
			exponent = Base64.getEncoder().encodeToString(exponentBytes);
	        
	        
	        
	        
	        
	        
//	        modulus = rsaPrivateKeySpec.getModulus().toString();
//	        exponent = rsaPrivateKeySpec.getPrivateExponent().toString();
	        
	        privateSignature.initSign(privaKey);
	        privateSignature.update(data.getBytes("UTF-8"));
	        byte[] s = privateSignature.sign();	  
	        
	     
	        encData = Base64.getEncoder().encode(s);  
	        
	         str = new String(encData,StandardCharsets.UTF_8).replaceAll("\r\n", "");
		} catch (Exception e) {
			return "X-JavaError" +" " +e.toString();
		}	   
	   return str+","+modulus+","+exponent;						  
	}
	public static String AESDecrypt(String message, String key) 
	   {		  
	 	  try {	 			 
	 		byte [] keybyte = key.getBytes("UTF-8"); 
		 	byte [] ivkey = Arrays.copyOf(keybyte,16);
	 		IvParameterSpec iv = new IvParameterSpec(ivkey);
	 		byte[] encvalue = Base64.getDecoder().decode(message);
	 		SecretKeySpec seckey= new SecretKeySpec(keybyte, "AES");
	 		Cipher c = Cipher.getInstance("AES/CBC/PKCS5PADDING");
	 		c.init(2,seckey,iv);
	 		byte[] decvalue=c.doFinal(encvalue);
	 		String decryptedvalue = new String(decvalue);
	 		return decryptedvalue;	 			 		
	 	} catch (Exception e) {	 	
	 		return "X-JavaError" +" " +e.toString();
	 	}	 	  
	   }	
	
	public static String getPrivateKey()
	{
	 		try {
	 			jkspwd = getProperty("aesk", propertiesPath); 
	 			enpass = getProperty("enpass", propertiesPath);
	    		boolean isAliasWithPrivateKey = false;
				KeyStore keyStore = KeyStore.getInstance("JKS");
				jkspwd = AESDecrypt(enpass, jkspwd);				
				if (!jkspwd.contains("X-JavaError"))
				{
				keyStore.load(new FileInputStream(jkspath), jkspwd.toCharArray());	             
				Enumeration<String> es = keyStore.aliases();
				String alias = "";
				while (es.hasMoreElements()) {
					alias = (String) es.nextElement();
					if (isAliasWithPrivateKey = keyStore.isKeyEntry(alias)) {
						break;
					}
				}				
				if (isAliasWithPrivateKey) {
					KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias,
					new KeyStore.PasswordProtection(jkspwd.toCharArray()));
					PrivateKey myPrivateKey = pkEntry.getPrivateKey();
					byte[] privateKey= (myPrivateKey.getEncoded());
				    base64PrivateKey = DatatypeConverter.printBase64Binary(privateKey);
				    }
				}
				else
				{
					base64PrivateKey = 	jkspwd + " : Error in Decryption of keystore password";
				}				
	 		}
		catch (Exception e)
		{
      		return "X-JavaError" +" " +e.toString();
		}
	     return base64PrivateKey;	
   	}
	public static String getPublicKey(String certPath)
	{
	 		try {
	 			FileInputStream fin = new FileInputStream(certPath);
				CertificateFactory f = CertificateFactory.getInstance("X.509");
				X509Certificate certificate = (X509Certificate)f.generateCertificate(fin);
				PublicKey publicKey = certificate.getPublicKey();
				byte[] pk = publicKey.getEncoded();
			    base64publickey = DatatypeConverter.printBase64Binary(pk);
			   fin.close();	 
	 		}				
		catch (Exception e)
		{			
      		return "X-JavaError" +" " +e.toString();			
		    }
	     return base64publickey;	
   	}
	
	
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.sbi.tcs;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Properties;

import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

import com.ibm.misc.BASE64Decoder;
import com.ibm.misc.BASE64Encoder;

public class NPS {
	static String jkspwd, enpass = "";
	static String base64PrivateKey, base64publickey = null;
	static HashMap<String, String> hashmap_public = new HashMap<>();

    //static String certPath="C:\\Users\\v1011334\\Desktop\\Cerificate\\EIS_ENC_UAT(2).cer";
	//new_nps
    //static String certPath="C:\\Users\\v1011334\\Desktop\\Cerificate\\NPS_Protean4.cer";
	//static String propertiesPath ="C:\\Users\\v1011334\\Desktop\\Cerificate\\KeyMapper.properties";
    //static String jkspath="C:\\Users\\v1011334\\Desktop\\Cerificate\\ibmdevportal.jks"; 
	
    // ************************************

   //static String certPath = "/opt/IBM/RSAKeystore/EIS_ENC_UAT_PUB.cer";
   // static String certPath="/opt/IBM/EndPoint_Public/capricorn.cer";
//    static String certPath_1="/opt/IBM/EndPoint_Public/NSDL_OVD_Pub.cer";
//    static String certPath="/opt/IBM/EndPoint_Public/NPS_2.cer";
     
    // ****************************
    
    static String certPath="/opt/IBM/EndPoint_Public/NPS_Protean4.cer";
    //static String certPath="/opt/IBM/EndPoint_Public/NSDL_OVD_Pub.cer";
    static String propertiesPath ="/opt/IBM/PropertyFile/KeyMapper.properties";
    static String jkspath = "/opt/IBM/RSAKeystore/ibmdevportal.jks";

	public static String getAlphaNumericString() {
		int n = 32;
		SecureRandom rnd = new SecureRandom();
		int n1 = 10000000 + rnd.nextInt(9999999);
		String ranNum = String.valueOf(n1);
		String secKey = ranNum + ranNum + ranNum + ranNum;
		StringBuilder sb = new StringBuilder(n);
		sb.append(secKey);
		return sb.toString();
	}

	public static String AESEncrypt_GCM(String message, String key) {
		try {
			byte[] keybyte = key.getBytes("UTF-8");
			byte[] ivkey = Arrays.copyOf(keybyte, 12);
			SecretKeySpec seckey = new SecretKeySpec(keybyte, "AES");
			Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
			GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, ivkey);
			c.init(Cipher.ENCRYPT_MODE, seckey, gcmParameterSpec);
			byte[] encvalue = c.doFinal(message.getBytes("UTF-8"));			
			String encryptedvalue = new BASE64Encoder().encode(encvalue).replaceAll("\r\n", "");
			return encryptedvalue;
		} catch (IOException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (NoSuchAlgorithmException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (NoSuchPaddingException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (InvalidKeyException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (InvalidAlgorithmParameterException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (IllegalBlockSizeException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
	}

	public static String AESDecrypt_GCM(String message, String key) {
		if (message.trim().length() == 0) {
			return "X-JavaError" + " " + "request body is empty";
		}
		try {
			byte[] keybyte = key.getBytes("UTF-8");
			byte[] ivkey = Arrays.copyOf(keybyte, 12);
			byte[] encvalue = new BASE64Decoder().decodeBuffer(message);
			SecretKeySpec seckey = new SecretKeySpec(keybyte, "AES");
			Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
			GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, ivkey);
			c.init(Cipher.DECRYPT_MODE, seckey, gcmParameterSpec);
			byte[] decvalue = c.doFinal(encvalue);
			String decryptedvalue = new String(decvalue);
			return decryptedvalue;
		} catch (IOException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (NoSuchAlgorithmException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (NoSuchPaddingException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (InvalidKeyException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (InvalidAlgorithmParameterException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (IllegalBlockSizeException e) {
			return "X-JavaError" + " " + e.toString();
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
	}

	public static String RSAEncrypt(String data) {
		String encData = "";
		try {
			/*
			 * if (base64publickey == null) { //String key = base64publickey =
			 * getPublicKey(certPath); String key = base64publickey =
			 * getPublicKey(crmPubKey); if (key.contains("X-JavaError")) { return
			 * "X-JavaError" + " " + key; } }
			 */
			// base64publickey = getPublicKey(certPath);
			base64publickey = getPublicKey(certPath);
			byte[] base64decpublivKey = new BASE64Decoder().decodeBuffer(base64publickey);
			X509EncodedKeySpec keySpec = new X509EncodedKeySpec(base64decpublivKey);
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			PublicKey pubKey = keyFactory.generatePublic(keySpec);
			Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPPadding");
			cipher.init(Cipher.ENCRYPT_MODE, pubKey);
			byte[] encdatabyte = cipher.doFinal(data.getBytes("UTF-8"));
			encData = new BASE64Encoder().encode(encdatabyte).replaceAll("\r\n", "");
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
		return encData;
	}
	

	public static String RSADecrypt(String encdata) {
		String data = "";
		try {
			if (base64PrivateKey == null) {
				base64PrivateKey = getPrivateKey();
			}
			// System.setProperty("com.ibm.crypto.provider.DoRSATypeChecking","false");
			byte[] privebase64decKey = new BASE64Decoder().decodeBuffer(base64PrivateKey);
			PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privebase64decKey);
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			PrivateKey privaKey = keyFactory.generatePrivate(keySpec);

			Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPPadding");
			cipher.init(Cipher.DECRYPT_MODE, privaKey);
			byte[] dataByte = new BASE64Decoder().decodeBuffer(encdata);
			data = new String(cipher.doFinal(dataByte));
		}

		catch (Exception e) {
			return "X-JavaError" + " " + e.getMessage();
		}
		return data;

	}

	public static String getPublicKey(String certPath) {
		try {
			FileInputStream fin = new FileInputStream(certPath);
			CertificateFactory f = CertificateFactory.getInstance("X.509");
			X509Certificate certificate = (X509Certificate) f.generateCertificate(fin);
			PublicKey publicKey = certificate.getPublicKey();
			byte[] pk = publicKey.getEncoded();
			base64publickey = DatatypeConverter.printBase64Binary(pk);
			fin.close();
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
		return base64publickey;
	}
	

	public static String AESEncrypt(String message, String key) {
		try {
			byte[] keybyte = key.getBytes("UTF-8");
			byte[] ivkey = Arrays.copyOf(keybyte, 16);
			IvParameterSpec iv = new IvParameterSpec(ivkey);
			SecretKeySpec seckey = new SecretKeySpec(keybyte, "AES");
			Cipher c = Cipher.getInstance("AES/CBC/PKCS5PADDING");
			c.init(Cipher.ENCRYPT_MODE, seckey, iv);
			byte[] encvalue = c.doFinal(message.getBytes("UTF-8"));
			String encryptedvalue = new BASE64Encoder().encode(encvalue).replaceAll("\r\n", "");
			return encryptedvalue;
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
	}

	public static String AESDecrypt(String message, String key) {
		try {
			byte[] keybyte = key.getBytes("UTF-8");
			byte[] ivkey = Arrays.copyOf(keybyte, 16);
			IvParameterSpec iv = new IvParameterSpec(ivkey);
			byte[] encvalue = new BASE64Decoder().decodeBuffer(message);
			SecretKeySpec seckey = new SecretKeySpec(keybyte, "AES");
			Cipher c = Cipher.getInstance("AES/CBC/PKCS5PADDING");
			c.init(2, seckey, iv);
			byte[] decvalue = c.doFinal(encvalue);
			String decryptedvalue = new String(decvalue);
			return decryptedvalue;
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
	}

	public static String digitalSignature(String data) {
		String encData = "";
		try {
			/*
			 * if (base64PrivateKey == null) { base64PrivateKey = getPrivateKey(); }
			 */
			base64PrivateKey = getPrivateKey();
			byte[] privebase64decKey = new BASE64Decoder().decodeBuffer(base64PrivateKey);
			PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privebase64decKey);
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			Signature privateSignature = Signature.getInstance("SHA256withRSA");
			PrivateKey privaKey = keyFactory.generatePrivate(keySpec);
			privateSignature.initSign(privaKey);
			privateSignature.update(data.getBytes("UTF-8"));
			byte[] s = privateSignature.sign();
			encData = new BASE64Encoder().encode(s).replaceAll("\r\n", "");
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
		return encData;
	}

	public static String getPrivateKey() {
		try {
			jkspwd = getProperty("aesk", propertiesPath);
			enpass = getProperty("enpass", propertiesPath);
			boolean isAliasWithPrivateKey = false;
			KeyStore keyStore = KeyStore.getInstance("JKS");
			jkspwd = AESDecrypt(enpass, jkspwd);
			if (!jkspwd.contains("X-JavaError")) {
				keyStore.load(new FileInputStream(jkspath), jkspwd.toCharArray());
				Enumeration<String> es = keyStore.aliases();
				String alias = "";
				while (es.hasMoreElements()) {
					alias = (String) es.nextElement();
					if (isAliasWithPrivateKey = keyStore.isKeyEntry(alias)) {
						break;
					}
				}
				if (isAliasWithPrivateKey) {
					KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias,
							new KeyStore.PasswordProtection(jkspwd.toCharArray()));
					PrivateKey myPrivateKey = pkEntry.getPrivateKey();
					byte[] privateKey = (myPrivateKey.getEncoded());
					base64PrivateKey = DatatypeConverter.printBase64Binary(privateKey);
				}
			} else {
				base64PrivateKey = jkspwd + " : Error in Decryption of keystore password";
			}
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
		return base64PrivateKey;
	}

	public static String getProperty(String key, String propertiesPath) {
		BufferedReader reader;
		try {
			reader = new BufferedReader(new FileReader(propertiesPath));
			Properties p = new Properties();
			p.load(reader);
			return p.getProperty(key);
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
	}

	public static String digiSignVerify(String data, String signature) {
		String SigVerify = "";
		try {
			/*
			 * if (base64publickey == null) { String key = base64publickey =
			 * getPublicKey(crmPubKey); if (key.contains("X-JavaError")) { return
			 * "X-JavaError" +" " + key; } }
			 */
			// base64publickey = getPublicKey(certPath);
			base64publickey = getPublicKey(certPath);
			{
				byte[] base64decpublivKey = new BASE64Decoder().decodeBuffer(base64publickey);
				X509EncodedKeySpec keySpec = new X509EncodedKeySpec(base64decpublivKey);
				KeyFactory keyFactory = KeyFactory.getInstance("RSA");
				PublicKey pubKey = keyFactory.generatePublic(keySpec);
				Signature privateSignature = Signature.getInstance("SHA256withRSA");
				privateSignature.initVerify(pubKey);
				privateSignature.update(data.getBytes());
				byte[] y = new BASE64Decoder().decodeBuffer(signature);
				boolean bool = privateSignature.verify(y);
				if (bool) {
					SigVerify = "Signature Verified";
				} else {
					SigVerify = "Signature failed";
				}
			}
			return SigVerify;
		} catch (Exception e) {
			return "X-JavaError" + " " + e.toString();
		}
	}

	public static void main(String[] args) {
		//String key = getAlphaNumericString();
		String key = "11111111111111111111111111111111";
		 //System.out.println("Key : "+key);
	    String data ="{\"header\":{\"requestId\": \"ICB230400797655111111030000005\",\"ipAddress\": \"12.12.12.13\",\"journeyType\": \"P\",\"responseType\": \"application/json\",\"serviceName\": \"LastContribution\",\"group\": \"P\",\"entityRegNumber\": \"5000214\",\"content-Type\" : \"application/json\"},\"payload\": {\"userId\": \"1300201WS\",\"pran\": \"110126502409\"}}"; 
	                  	  
//			"{\r\n" + 
//				"        \"drivinglicencenumber\":\"TS28Q12340854\",\r\n" + 
//			"      \"dob\": \"01/12/2020\",\r\n" + 
//			"        \"rrn\":\"234567\"\r\n" + 			"    }";
		
		String AESkey = RSAEncrypt(key);
		System.out.println("ACCESSTOKEN: " + AESkey);
		String ENC = AESEncrypt_GCM(data, key);
		String digi = digitalSignature(data);
		
		
		//System.out.println();
		
	//	System.out.println(digitalSignature("{\"drivinglicencenumber\":\"MH1020180004422\",\"dob\":\"29/07/1999\",\"rrn\":\"SBICB23049749776759789289\"}"));
		
		//System.out.println(digiSignVerify("{\"SOURCE_ID\":\"FO\",\"CUSTOMER_NUMBER\":\"00000086094075002\",\"REQUEST_REFERENCE_NUMBER\":\"SBIFO23130002405665359216\"}","jcB6/BL4QuzmB8VDER2zNY3XcKtsFm5Pd0BX+0fDKluRL7WhT2ixQ4/+i9aejdPnFW9qpwTYF3U8Tf/8MN9YAA=="));
		System.out.println("REQUEST: "+ ENC);
		System.out.println("DIGI :"+digi);
		//System.out.println("AESkey : " +AESkey);
	    //System.out.println("request: "+ AESEncrypt_GCM(data, key));
		//String decData=AESDecrypt_GCM("DXTx20EjQCRg0roj2IeqaId4R9AWRrmonAHaIHtuQQQYmVMqzdFH4PdSKaBiAqaH26oaWNWOoJc98mLyfL6pXqEhouAEKoQ77eGVZEeY6o+pjzXe7PbVYtfuhKbXMoLN72sgPdvu", "11111111111111111111111111111111");
		//String decData="{\"drivinglicencenumber\": \"MH1020180004422\",\"dob\": \"29/07/1999\",\"rrn\": \"SBICB23049749776751580191\"}";
		//System.out.println(decData);
		//String AESKey = RSADecrypt("APP3DAo37zu0GWxztSG7Q1Zea3orahMnYTzhtCLGTh2j52D+uxuCUA4puoforXIdIDfnfVc/0IT4zWnXPKbo+YzBtLv8WADbhK0ZwPYrBeMGqaoyT4V2viWiOpApHPHiQrzM46S3ag7IOw6jU/l7DlNWsnvUjBZFysiQ43mS7ooWGl53F+IkEHAyQjcuA9y1UbMtXwjmlOmSQ+8cCQi1vTbpwyNksIwEnwRporr/QaUkKce1HV+bR1WsgdtTjuXF19uoC1mtJoUw41UZUXDNl2kW7dtXtTHZy3QItaZo1E4/GaVNQrWech+uvrxGpsZy9vqBYA0MO+C1rmpkDjeUTQ==");
		//System.out.println("AESKeydec: "+ AESKey);
		String decData =  AESDecrypt_GCM("DXTnwEUhBlswkeRhmpemJpUsGoVDALewyi/aPC9QSRtOl0sUxIFc+99TGvsoRcrS2YxOC4zJsIxz4H/uU7f/ULlm5aJbdvdkq6iVOgS6w+mjnj7MvMXrapKyAUF79+32RXm5Lf976H8HPQyExaTamtBQUMyCHdBqqjkFG9a7sjxGkvvarXgLXXEKASJPAfhUJqKE8xr45N0UQwThljj2hdp0JHTgsACQdF3IAuHjEk/OkwCJ9JzWSsr2q1WcZQPP7vZzT/m2H02IzfIp6wFbF6I=", "11111111111111111111111111111111");
		System.out.println(decData);
		//System.out.println(digiSignVerify(decData,"ZBXDols+6qRYsOWwMhgA3/a0CiE/15dXRV2M96L/V+bNsnhIR6yOrV/S7WsWWxGOcdBUIvYoJ8DoCSEE5wiGbWNdSDUvNsM0jPhUn5yezre/aSNdjvMH/tCfy+ukds5/O0AltOr1J1jDCctuUN0h3/gY/g/8SDtyF44Tv3vLugIHM0z9C4qh0vPd+hQCrzvD+tu1CcyEyzP+wg1z2NxoIrCPCFVwHrLr+ILpI6kAH8wfC//xd4cv/4puE6D3GX8N0GXzgf3wvw0Lmx8lLkApA5AW6TW6xpHu73Xwo8Ov7mOjCo95SX04WgNVg8u+MRm/D9Um7JhJn6s0X3ny1JrF4Q=="));
		//String decRSAKey =  RSADecrypt("VKv65DZyL32sP7xmxBLRn7A2EFJ6z2QXS0x7sADgR6WtsNVP295J0RdFl9FJ/aYbx034P34ZIzRDh05r9Tr8mI0yvn2gpvnSI6zENp9DG9+kYXlT3/peSfQqFXeShIqdFQgtkVyIm0cFjovQag+ryyNCAKKnRf27C8yoMJarq2AQF7KS05hB0ZGbw3scQkK3hln5DC2P+vyVXbqw5Lu3WZyNQbidi0fPmBjjvcPRzBXgWd/XToviQoPMghAK+FRKh+b3Lk7DpScsxS3Md58XzyHw6Hg74WPVThTda4lEKz88SfMAtHDPPTTR2qMTwCo4AzumNPmgcpprIupKnprq2g==");
	//	System.out.println("Decrypted RSA : "+digiSign);
		//System.out.println (ABC);
		// String digiSign = digitalSignature(data);
		// System.out.println("digiSign : "+digiSign);
		// String aesDec =
		 //RSADecrypt("NCTRpfnkV4YaSRBHmbd/KFtXHLq4YIvImYChOrVI0n3Ahhm2D5VGihXqxSMW00qyUDJRN40RyRXZYgn/Y5Duf01y9jLAPYi9vVT++UpqQQycuT0KQOuL3hj8THo+umRGVM5JXhu/GS9SXBuYk+l39OoZWlV62EeZm9z+sGbnjLKe6w5am9mXMALAeSZNLhVmqmYGKhaumR2cEALu5J8fpCUGh+/5FmlUEcZJha70qIzPH8or7L/IxTgbR+4EZ6Rng5wPVRsms5QSxxSYMrsB6nYQFNM9NIdF1frE7Z9ZhY8LnwH0mOacXcsMgoMMZzVMgQ4fzsPGW6BgCI6RVLnXvw==");
		 //System.out.println("AESkey : "+rsaDec);
		//System.out.println("DecKey:
		// "+RSADecrypt("lljrKeX510qtE9dGVRvjXPT2zsA5BHZrty7EqGo/RF1m0Fy2g8jCpb9wC8YNYVIZC0DiZ53m9IdZCHO5/wza7+O6ULU30K1REBwHbdcKPS4w5wYYMOGjS2uB1BGLk6UrpYHlf034aj82dp7Tb0SHxwSXWrL07V805NTmAL7cto+Xiyfl9YDWLbjKtnFpqmDcNfL0sRF76+zRT7obg9LragqxygVSGgYtdZZjcQ1lu0rtvCWwoiIXltVkYxDGQRJe7r2S6jl/tzan8m5PNanwgguI3X3uzYU3kqTurSak3zXMaLOWgwa71waq5pKtwgJ9Ypc+D8RuAW8puvTkQ8LHQg=="));
		String digiSingData = "GUIb3LHpGq4jFQ6Qye4MNnS/ATyu3k62KAnT2DnsLwbEgfFekARqooPyJYLd1qeChJS6qmB1waGsbrqaURmH7byK2+Z9oAEBJ0VNoqD+ij0roqNa9z35DERknJ8rKEXqLW6M2kmThbWXYd/J3PUiv5JZJ7ioB7ETTOXaJr6fwjkOzORZDUSTOefN6UJROn+UDPzACG647WTdoYpQ+iZGwJI4/Nle+O0Tgk/90Fm9zF/dF3MZ66THWeTWasr2AAe+Yvh7yb+xqQYiEXJKFyQ9lHoW8RzfdQY535i37SySq4XPcCAZ8HY0bnprEd2gRtC6Ts6Z6LeoM//KdS8Mzd5k6w==";
		System.out.println(digiSignVerify(decData,digiSingData));
		// String rsaDec =
		 AESDecrypt_GCM("mNnW4L7Iy/tKEcRdmwkPOypXmrGwL6uK/R+lYxYFEi+tmzenN7ZViuazGP/a5XX8l4F4EujSsBHP1OOrC6/0hYcE3Nz1+HSNZl1dL6S+ZiJG7wbcAZRvVdPnmpsZaPI9P9gGIQtqRkx9fwjLjV4km3bJfXu7XCPiyjarqv6tMWdZtL2qMT97he1V56WatHSOmk+UDcijYUROc5zUXQYch5y8/+5OCBIjvJ5mLreNmhfLCY4NjqiXxODhXyeJc24T5OR+9VDDnf2A2hnT/cXJE8xiIEdfdxaDWYNxCma/Uv4RAP8g8rI2J3UjR5JaJhEZEE46ME+i4rvSFdhAilRtMw==","11111111111111111111111111111111");
		// System.out.println("DecData "+rsaDec);
		//System.out.println(AESDecrypt_GCM("kIPDm2K9vqwNbEVSgJuvlBqQLeSKxYDMy+dVxB55EETtENag9an8DZoGTCZmfKGFOFevsHG+9zHBbSPJf/OTmx0L+hvRGc3r1xAyWnL1WQfJprSTmDkVKhHjBC5zjUpg9skrL2/rS74P", key));
		//String key =RSADecrypt("VKv65DZyL32sP7xmxBLRn7A2EFJ6z2QXS0x7sADgR6WtsNVP295J0RdFl9FJ/aYbx034P34ZIzRDh05r9Tr8mI0yvn2gpvnSI6zENp9DG9+kYXlT3/peSfQqFXeShIqdFQgtkVyIm0cFjovQag+ryyNCAKKnRf27C8yoMJarq2AQF7KS05hB0ZGbw3scQkK3hln5DC2P+vyVXbqw5Lu3WZyNQbidi0fPmBjjvcPRzBXgWd/XToviQoPMghAK+FRKh+b3Lk7DpScsxS3Md58XzyHw6Hg74WPVThTda4lEKz88SfMAtHDPPTTR2qMTwCo4AzumNPmgcpprIupKnprq2g==");
		//System.out.println(key);

	}
}

